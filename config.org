* Emacs Configuration

This is my emacs configuration. This was heavily inspired by Harry Schwartz
(you can check github.com/hrs or search for a great talk about emacs by him.

* Setup =use-package=

This file uses =use-package= to install any further packages. =use-package=
itself was already set up in =init.el=. Here I'm making sure that missing
packages are always installed, compiled and updated, so it works as expected
for any of the following sections.

#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)

(use-package auto-compile
  :config (auto-compile-on-load-mode))

(setq load-prefer-newer t)
#+END_SRC

* Helper Functions

The following is just a shorthand for lambda functions that's
mostly used for =evil-leader= keybindings, since they have to
be interactive

#+BEGIN_SRC emacs-lisp
(defmacro λ! (&rest body)
  `(lambda () (interactive) ,@body))
#+END_SRC

* Backup behavior

Emacs usually creates backup files in the same directory as the actual files.
I don't really like that. Setting these up to put them all in the same folder
(just to be safe) and keeping a few of them.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.backups")))
(setq backup-by-copying t)
(setq delete-old-versions t
      kept-new-versions 4
      kept-old-versions 2
      version-control t)
#+END_SRC

* Configure =evil-mode=

Vim emulation. With out this (and =helm=) I'd be hopelessly lost in emacs. Set
up =evil= and some sane defaults.

We need to load this pretty early so that other packages can use =evil-leader=
keybinds.

#+BEGIN_SRC emacs-lisp
(setq evil-want-abbrev-expand-on-insert-exit nil)
(use-package evil
  :config
  ;; (evil-set-initial-state 'dashboard-mode 'normal)
  (evil-mode 1))
#+END_SRC

Enable =evil= in =org-agenda=:

#+BEGIN_SRC emacs-lisp
(use-package evil-org
  :after org
  :config
  (add-hook 'org-mode-hook 'evil-org-mode)
  (add-hook 'evil-org-mode-hook (λ! (evil-org-set-key-theme)))
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys))
#+END_SRC

Set up =evil-leader= with =<SPC>= as the leader key (like spacemacs).

#+BEGIN_SRC emacs-lisp
(use-package evil-leader
  :config
  (evil-leader/set-leader "<SPC>")
  (evil-leader-mode 1)
  (global-evil-leader-mode 1))
#+END_SRC

* Replace Default Buffer with =dashboard=

The package =dashboard= replaces the sucky default buffer with a helpful
list of recent files, projects and bookmarks. Additionally,
=initial-buffer-choice= is set, so that new =emacsclients= also use this.

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :config
  (setq initial-buffer-choice (λ! (get-buffer "*dashboard*")))
  (setq dashboard-banner-logo-title "Emacs Dashboard")
  (setq dashboard-startup-banner "~/.emacs.d/logo.png")
  (setq dashboard-center-content t)
  (dashboard-setup-startup-hook))
#+END_SRC

* Theming/Appearance
  
Use =fira-code= as default font. Also bump up the font size because my eyes are
bad. Unfortunately, =emacs= does not support font ligatures (yet).

#+BEGIN_SRC emacs-lisp
(set-default-font "Fira Code 13")
(setq default-frame-alist '((font . "Fira Code 13")))
#+END_SRC

I use =nord-theme= for now. Emacs 24+ supports theming out of
the box, so we just have to fetch the actual theme from MELPA and
turn it on.

Note that =nord= won't actually work with =emacsclient= because of
an issue in the package. If you initialize a new config from this
file you'll have to apply [https://github.com/arcticicestudio/nord-emacs/pull/68]
if the issue is not yet fixed.

#+BEGIN_SRC emacs-lisp
(use-package nord-theme
  :defer t
  :init
  (if (daemonp)
    (add-hook 'after-make-frame-functions
      (lambda (frame)
        (load-theme 'nord t)))
    (load-theme 'nord t)))
#+END_SRC

Next, load in the =powerline= from =spacemacs= as well.

#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :config
  (spaceline-spacemacs-theme))
#+END_SRC

I don't like/need things like the menu bars and scroll bars. Also set 
buffers be transparent by default.

#+BEGIN_SRC emacs-lisp
(tool-bar-mode 0)
(menu-bar-mode 0)
(scroll-bar-mode -1)
(set-window-scroll-bars (minibuffer-window) nil nil)

(set-frame-parameter (selected-frame) 'alpha '(95 . 75))
(add-to-list 'default-frame-alist '(alpha . (95 . 75)))
#+END_SRC

* Linum Mode

Always show line numbers, except in org mode where the folding breaks.

#+BEGIN_SRC emacs-lisp
(setq linum-format "%d ")
(global-linum-mode)
(add-hook 'org-mode-hook (λ! (linum-mode 0)))
#+END_SRC

* FCI and Autofill
  
Activate =fill-column-indicator= to keep me from writing
overly long lines. The indicator is disabled on all special buffers
(wrapped in *s) and in =dired-mode=.

#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :config
  (setq fci-rule-column 80)
  (setq fci-rule-use-dashes 1)
  (setq fci-rule-width 1)
  (define-globalized-minor-mode global-fci-mode fci-mode
  (lambda ()
    (if (and
      (not (string-match "^\*.*\*$" (buffer-name)))
      (not (eq major-mode 'dired-mode)))
    (fci-mode 1))))
  (global-fci-mode 1))
#+END_SRC

* Toggles
  
The following keybinds toggle certain things that frequently need
to be changed (mostly modes).

#+BEGIN_SRC emacs-lisp
;; Mnemonic "fill"
(evil-leader/set-key "t f" 'auto-fill-mode)
;; Mnemonic "indicator"
(evil-leader/set-key "t i" 'fci-mode)
;; Mnemonic "linum"
(evil-leader/set-key "t l" 'linum-mode)
#+END_SRC

* Quick File Access

Some files need to be edited a lot (mostly configs and org-journals). Provide
some handy keybinds for them here.

#+BEGIN_SRC emacs-lisp
; Mnemonic: "config"
(evil-leader/set-key "f c" (defalias (make-symbol "edit-config")
                              (λ! (find-file "~/.emacs.d/config.org"))))
; Mnemonic: "notes"
(evil-leader/set-key "f n" (defalias (make-symbol "edit-notes")
                              (λ! (find-file "~/Documents/notes.org"))))
; Mnemonic: "thesis"
(evil-leader/set-key "f t" (defalias (make-symbol "edit-thesis-notes")
                              (λ! (find-file "~/Documents/fh/thesis/thesis.org"))))
#+END_SRC

* Window Management

First of all, use spacemacs's =winum= to get numbered windows for easy switching,
then bind =<Leader> {n}= to =winum-select-window-{n}=.

#+BEGIN_SRC emacs-lisp
(use-package winum
  :config
  (evil-leader/set-key "1" 'winum-select-window-1)
  (evil-leader/set-key "2" 'winum-select-window-2)
  (evil-leader/set-key "3" 'winum-select-window-3)
  (evil-leader/set-key "4" 'winum-select-window-4)
  (evil-leader/set-key "5" 'winum-select-window-5)
  (evil-leader/set-key "6" 'winum-select-window-6)
  (evil-leader/set-key "7" 'winum-select-window-7)
  (evil-leader/set-key "8" 'winum-select-window-8)
  (evil-leader/set-key "9" 'winum-select-window-9)
  (setq winum-auto-setup-mode-line nil)
  (winum-mode 1))
#+END_SRC

Additionally, allow splitting windows using =w /= and =w -= . These windows
will be automatically numbered by =winum= anyway.

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key "w /" 'split-window-right)
(evil-leader/set-key "w -" 'split-window-below)
#+END_SRC

Delete current window with =w d=.

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key "w d" 'evil-window-delete)
#+END_SRC

Allow switching buffers with =b p= and =b n=. Delete buffers with =b d=.

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key "b p" 'evil-prev-buffer)
(evil-leader/set-key "b n" 'evil-next-buffer)
(evil-leader/set-key "b d" 'evil-delete-buffer)
#+END_SRC

* Lisp Trickery

Here is some setup to make lisp hacking a bit easier. The following
snippet allows evaluating the currently selected expression or the
whole buffer.

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key "e l" 'eval-last-sexp)
(evil-leader/set-key "e b" 'eval-buffer)
(evil-leader/set-key "e e" 'eval-expression)
#+END_SRC

* Configure =helm=

Load in =helm=, a great framework for incremental completion,
then, as always, set up keybinds with =evil=.

#+BEGIN_SRC emacs-lisp
(use-package helm
  :config
  (evil-leader/set-key "<SPC>" 'helm-M-x)
  (evil-leader/set-key "f f" 'helm-find-files)
  (evil-leader/set-key "f r" 'helm-recentf)
  (evil-leader/set-key "b b" 'helm-mini)
  (add-to-list 'helm-boring-file-regexp-list "^\\.")
  (add-to-list 'helm-boring-file-regexp-list "~$")
  (helm-mode 1))
#+END_SRC

Also get =helm-descbinds=, which allows to search for keybinds
using =C-h=.

#+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
  :config
  (helm-descbinds-mode))
#+END_SRC

* Configure =which-key=

=which-key= uses the minibuffer to interactively drill down into
keybinds. Neato!

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :config
  (which-key-mode))
#+END_SRC
* Configure =projectile=

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
  (setq projectile-completion-system 'helm))
 
(use-package helm-projectile
  :config
  (evil-leader/set-key "p f" 'helm-projectile-find-file)
  (helm-projectile-on))

#+END_SRC

* Configure =org-pomodoro=

Org-pomodoro allows starting pomodoros on org tasks , automatically
tracking spent time and playing audio notifications when pomodoros and
breaks start/end.

The default modeline sucks, so I'm using the package's hooks to write
to a file that I display on my =i3bar=.

This doesn't exactly work :/

#+BEGIN_SRC emacs-lisp

(setq jwinkler-org-pomodoro-minutes 0)
(setq jwinkler-org-pomodoro-file "~/tmp/.org-pomodoro")

(defun pomodoro-start ()
  "Called when starting a pomodoro. Writes the time to a
   temporary file to read with i3bar"
  (setq jwinkler-org-pomodoro-minutes 25)
  (with-temp-file jwinkler-org-pomodoro-file
    (insert "25 min"))
)

(defun pomodoro-tick ()
  "Called whenever a pomodoro ticks (every second). Updates
   the remaining minutes in the temporary file"
  (setq jwinkler-org-pomodoro-minutes (- (/ org-pomodoro-remaining-seconds 60) 1))
  (with-temp-file jwinkler-org-pomodoro-file
    (insert "tick"))
)

(defun pomodoro-done()
  "Called whenever a pomodoro is finished (or killed). Updates
   the temporary file to say inactive."
  (with-temp-file jwinkler-org-pomodoro-file
    (insert "done."))
)   

(use-package org-pomodoro
;;  :config
;;  (add-hook 'org-pomodoro-started-hook 'pomodoro-start)
;;  (add-hook 'org-pomodoro-tick-hook 'pomodoro-tick)
;;  (add-hook 'org-pomodoro-finished-hook 'pomodoro-done)
)
#+END_SRC
* Configure =vhdl-mode=

#+BEGIN_SRC emacs-lisp
(setq vhdl-company-name "Jakob Winkler")
(setq vhdl-clock-name "clk_i")
(setq vhdl-reset-name "reset_in")
(setq vhdl-testbench-declarations "  -- clock
  signal clk : std_ulogic := '1';
")
(setq vhdl-testbench-entity-file-name (quote (".*" . "\\&-ea")))
(setq vhdl-testbench-entity-name (quote (".*" . "tb_\\&")))
(setq vhdl-testbench-include-configuration nil)
(setq vhdl-testbench-include-library nil)
(setq vhdl-testbench-statements
   "  -- clock generation
  clk <= not clk after 10 ns;

  stimul: process
  begin
    wait until rising_edge(clk);
  end process stimul;
")
(setq vhdl-file-header
"-------------------------------------------------------------------------------
-- Title      : <title string>
-- Project    : <project>
-------------------------------------------------------------------------------
-- File       : <filename>
-- Standard   : <standard>
-- <copyright>-------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

")
#+END_SRC
